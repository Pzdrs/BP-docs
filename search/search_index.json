{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introducing ES-GPS","text":""},{"location":"#_1","title":"Introducing ES-GPS","text":"<p>Introducing our cutting-edge position tracking solution! With a powerful web application dashboard and hardware GPS data source, you can effortlessly keep tabs on your assets, vehicles, or loved ones. Our solution provides real-time location updates, allowing you to monitor and manage everything from a single platform. Stay in control and make informed decisions with our reliable and user-friendly system. Experience the convenience and peace of mind that comes with our position tracking solution.</p> <p> </p>"},{"location":"dashboard/","title":"The ES-GPS dasbohard","text":"<p>Effective positional data collection relies heavily on the ability to analyze the gathered data post-collection. The ES-GPS dashboard facilitates this analysis by enabling users to query and visualize data on an interactive map. Deploying this dashboard is essential for user access, and this documentation section outlines the prerequisites for deployment. It also provides guides for various deployment options. Once successfully deployed, instructions on utilizing the interface and its features are provided at the conclusion of this section.</p>"},{"location":"dashboard/installation/","title":"Installation","text":"<p>You have a two main options for deploying the ESGPS dashboard, depending on your needs. The recommended and most well documented option is Docker. With the help of Docker Compose, you can have the dashboard up and running in a matter of minutes. We offer docker images for a majority of platforms. You can also install and run the dashboard from source if Docker is not your thing.</p> <p>The ES-GPS application consists of two primary components: the back-end, responsible for handling the heavy lifting, and the front-end, which serves as the user interface. A third crucial component is a proxy server tasked with routing requests to the appropriate back-end or front-end based on the domain name. Although not directly integrated into the ES-GPS application, this proxy server is indispensable for the application's proper functionality. Nginx stands out as the recommended choice for this role, and accordingly, we provide the necessary configuration files for its setup.</p>"},{"location":"dashboard/installation/#back-end","title":"Back-end","text":"<p>The back-end is a Java application that uses the Spring Boot framework. It is responsible for handling all the business logic, as well as communicating with the database and the MQTT broker. It also serves as the front-end API.</p> <p>Java applications are packaged into JAR files, which can be run on any machine, thanks to the JVM (Java Virtual Machine), which makes Java applications platform-independent.</p>"},{"location":"dashboard/installation/#front-end","title":"Front-end","text":"<p>The front-end is a separate web application that uses the back-end's API to read and write data while providing a user-friendly interface. The application is built using the Vue.js framework, which is a popular JavaScript framework for building user interfaces and single-page applications.</p>"},{"location":"dashboard/installation/docker/","title":"Docker Installation","text":"<p>Containerization is not a new concept, but it has gained a lot of traction in recent years. Docker is one of the most popular containerization tools, and it is used to package applications and their dependencies into isolated containers. This allows for easy deployment and scaling of applications, as well as ensuring that the application runs the same way on different environments. LXC (Linux Containers) is another popular containerization tool, but Docker, which is built on top of LXC, is more user-friendly and has a larger community.</p> <p>As the Docker images are not hosted anywhere publicly available, the repository needs to be cloned and the images built manually. A convenient Docker Compose file configured with the necessary image contexts is available to the user.</p>"},{"location":"dashboard/installation/docker/#before-you-get-started","title":"Before you get started","text":"<p>1) Docker and Docker Compose installed on your machine.</p> <p>2) A working internet connection to clone the repository.</p>"},{"location":"dashboard/installation/docker/#installation","title":"Installation","text":"<p>1) Clone the ES-GPS repository:</p> <pre><code>git clone https://github.com/Pzdrs/BP-app.git\n</code></pre> <p>2) Navigate to the <code>BP-app</code> directory:</p> <pre><code>cd BP-app\n</code></pre> <p>3) Docker Compose is expecting Mongo credentials placed in a <code>.env</code> file:</p> <pre><code>MONGO_USERNAME=user\nMONGO_PASSWORD=password\n</code></pre> <p>Common pitfall</p> <p>Make sure the <code>.env</code> file is located in the same directory as the <code>docker-compose.yaml</code>.</p> <p>4) Run the following command to start the ES-GPS dashboard:</p> <pre><code>docker-compose up --build\n</code></pre> <p>5) As the dashboard is expecting to be accessed at <code>http://esgps.pycrs.cz</code>, a DNS record needs to be added to the zone file for the domain pycrs.cz:</p> <p>If the container is deployed with the Macvlan or IPvlan network, thus it has its own IP address:</p> <pre><code>esgps     IN      A     10.0.0.15 # replace with the actual IP address\n</code></pre> <p>If placed behind a reverse proxy (recommended):</p> <pre><code>traefik   IN      A     10.0.0.25 # example\n\nesgps     IN      CNAME     traefik\n</code></pre> <p>6) The dashboard is now up and running and depending on the DNS configuration, accessible at <code>https://esgps.pycrs.cz</code>.</p>"},{"location":"dashboard/installation/source/","title":"Source Installation","text":"<p>Aimed at experienced users</p> <p>As installation from source is way more involved than Docker installation, there are presumptions about the readers' experience, thus not every single step is documented.</p> <p>Of course, as the entire code base of the application is open-source and available on GitHub, installation from source is an option for experienced users who want special control over the deployment.</p> <p>Similarly to the previous section about Docker installation, the repository needs to be cloned first:</p> <pre><code>git clone https://github.com/Pzdrs/BP-app.git\ncd BP-app\n</code></pre>"},{"location":"dashboard/installation/source/#back-end","title":"Back-end","text":"<p>Starting with the back-end, the Java application needs to be packaged into a JAR file first, before it can be run. The project uses Gradle and the wrapper is included in the repository, which makes this step very straightforward.</p> <pre><code>cd backend\ngradle build -x test # skipping tests, as there are none ;)\n</code></pre> <p>This packages the application into a JAR file and places it into the <code>build/libs</code> directory. Now that we have a JAR file, we can start the application with the following command (you might want to move the file to a more permanent location first):</p> <pre><code>java -jar build/libs/backend-0.0.1-SNAPSHOT.jar\n</code></pre>"},{"location":"dashboard/installation/source/#front-end","title":"Front-end","text":"<p>The front-end part of the application is somewhat less involved. The first step is to install the dependencies listed in <code>package.json</code>.</p> <pre><code>npm install\n</code></pre> <p>After all dependencies are installed comes thet build process by running the appropriate <code>npm</code> script, which uses the Vite build lifecycle.</p> <pre><code>npm build\n</code></pre> <p>This builds the application and places the output files in the <code>dist</code> directory.</p>"},{"location":"dashboard/installation/source/#nginx","title":"Nginx","text":"<p>Nginx can be installed in multiple different ways. The simplest way is to use a package manager (<code>apt</code> in this case):</p> <pre><code>apt install nginx\n</code></pre> <p>The front-end build files should at this stage be moved to the <code>/usr/share/nginx/html</code> directory.</p> <p>The necessary configuration is included in the <code>nginx</code> directory of the cloned repository (<code>default.conf</code>).</p> <p>Running Nginx is now as simple as:</p> <pre><code>nginx -g daemon off;\n</code></pre>"},{"location":"dashboard/prerequisites/","title":"Prerequisites","text":"<p>Before even getting to the deployment process, a few prerequisites need to be established. The application mainly relies on a database for storing application and positional data and an MQTT broker from which the application will subscribe data.</p>"},{"location":"dashboard/prerequisites/#database","title":"Database","text":"<p>The ES-GPS dashboard used a document-based database MongoDB. Unlike the MQTT server, the connection details must be specified at deploy time, meaning it can't be changed at run time. The connection parameters are passed to the back-end by using environment variables. There are 3 required parameters that must be passed to the back-end in order for it to start:</p> <ul> <li><code>MONGO_HOST</code> (required)      hostname or IP of the database</li> <li><code>MONGO_USERNAME</code> (required)</li> <li><code>MONGO_PASSWORD</code> (required)      if no password is set, an empty string must be passed</li> </ul> <p>With these three parameters, given the server and the database can reach each other over the network, the backend is able to connect to the database. By default, the port 27017 is used to establish the connection, which is the default MongoDB port. If, for some reason, a different port needs to be used, the <code>MONGO_PORT</code> environment variable can be passed to the back-end with the specific port.</p> <p>There are a couple of different ways to deploy a MongoDB instance. One way is to use Mongo Atlas to deploy an instance in the cloud (a free tier is available). Another option is to deploy it yourself. It can be downloaded as a package using your favorite package manager, or Docker can be employed, which makes things much easier. Using plain Docker, a Mongo instance can be spun up with the following command.</p> <pre><code>$ docker run --name some-mongo -d mongo:tag\n</code></pre> <p>In case Docker Compose is used, the following service definition is added to the <code>docker-compose.yaml</code>.</p> <pre><code>mongo:\n    image: mongo\n    restart: always\n    environment:\n      MONGO_INITDB_ROOT_USERNAME: root\n      MONGO_INITDB_ROOT_PASSWORD: example\n</code></pre> <p>It also may be wise to use bind mounts or volumes in order to persist data across container restarts. More information on that topic can be found in the official documentation.</p>"},{"location":"dashboard/prerequisites/#mqtt-server","title":"MQTT server","text":"<p>The MQTT protocol operates on the principle of a broker and end devices. At its core lies a central server, often termed as a \"broker\" in messaging parlance, which orchestrates data communication among devices. This setup revolves around a publish-subscribe model, wherein publishers\u2014typically data sources like sensors or location tracking devices\u2014transmit data (messages) to the central broker, which manages active subscribers.</p> <p>Each message is published on a so-called topic, an organizational unit within the MQTT architecture. In case of this project, the data sources publish data on the esgps/gnss topic that is then also subscribed to by the application. When a message arrives at the broker, it is relayed to all active subscribers listening to that specific topic. </p> <p>There are many open-source brokers, most notably the following:</p> <ul> <li>Eclipse Mosquitto</li> <li>RabbitMQ</li> <li>HiveMQ</li> <li>Redis (an in-memory database that can be leveraged to act as a message queue)</li> </ul> <p>During development, both Mosquitto and RabbitMQ were used and are, therefore, the officially supported message brokers of this project.</p> <p>In case no preexisting message broker is available, the deployment of one is equally as simple as MongoDB in the previous section. Here is an example of how to deploy a RabbitMQ instance using Docker Compose.</p> <pre><code>version: '3.7'\n\nservices:\n  rabbitmq:\n    image: rabbitmq:tag\n    hostname: my-rabbit\n    container_name: rabbitmq\n    restart: unless-stopped\n    environment:\n      - RABBITMQ_DEFAULT_USER=username\n      - RABBITMQ_DEFAULT_PASS=password\n    ports:\n      - \"5672:5672\"  # RabbitMQ default port\n      - \"1883:1883\" # MQTT\n    command: | \n        \"/bin/bash -c \\\"rabbitmq-plugins enable --offline rabbitmq_mqtt rabbitmq_web_mqtt rabbitmq_amqp1_0; rabbitmq-server\\\"\"\n</code></pre> <p>The details of configuring the MQTT broker at run-time are covered in the Usage chapter.</p>"},{"location":"dashboard/usage/","title":"Usage","text":"<p>usage</p>"},{"location":"data-source/","title":"Data Source","text":"<p>The term Data Source refers to the hardware package flashed with the data source firmware.</p> <p>This section of the documentation covers the initial construction, the process of flashing it with the firmware and its configuration. A Troubleshooting section at the end is dedicated to some common pitfalls you might experience during use.</p>"},{"location":"data-source/configuration/","title":"Configuration","text":"<p>The ESP32 runs a web server that allows you to configure the device. To access the web server, you need to connect to its WiFi network and navigate to the web interface. The following steps will guide you through the process:</p> <ol> <li>Power on the device by connecting it to a USB power source.</li> <li>Wait for the device to boot up. Either wait till it connects to a WiFi network indicated by the integrated blue LED or wait for it to time out</li> <li>Press the dedicated button on the device to enable the WiFi hotspot. The other blue LED will light up to indicate that the hotspot is active.</li> <li>Connect to the WiFi network named <code>ESGPS-&lt;MAC&gt;</code> where <code>MAC</code> is the MAC address of the device's WiFi interface (e.g. <code>ESP-1A:2B:3C:4D:5E:6F</code>). There is no password required to connect to the network.</li> <li>Open a web browser and navigate to <code>http://192.168.0.1</code> - the IP address of the \"router\".</li> <li>You should see the configuration page. If you don't, try refreshing the page or power cycling the device.</li> </ol>"},{"location":"data-source/configuration/#wifi-configuration","title":"WiFi configuration","text":"<p>In the WiFi configuration section, you can configure the device to connect to your WiFi network. The device will automatically connect to the last connected network on boot. </p> <p></p>"},{"location":"data-source/configuration/#mqtt-configuration","title":"MQTT configuration","text":"<p>In the MQTT configuration section, you can configure the device to connect to an MQTT broker. It is necessary to provide the credentials as well as the broker's IP address (or hostname). The port is optional and defaults to 1883.</p> <p></p>"},{"location":"data-source/configuration/#gnss-debugging","title":"GNSS debugging","text":"<p>An additional debugging feature is available to help you debug GNSS issues. This section is getting real-time GNSS data over WebSockets giving you the ability to see the raw data coming from the GNSS module.</p> <p></p>"},{"location":"data-source/construction/","title":"Construction","text":"<p>The hardware package is assembled on a no-solder breadboard. The wiring diagram below shows how everything is connected together.</p> <p></p>"},{"location":"data-source/construction/#components","title":"Components","text":"<p>The two main components are the u-blox NEO-M8 GNSS module and the MPU6050 accelerometer + gyroscope module.</p>"},{"location":"data-source/construction/#gnss-module","title":"GNSS module","text":"<p>The GNSS module can be subsituted for pretty much any other available module, that communicates over Serial. The firmware is expecting valid NMEA messages on the Serial line with the following settings:</p> <ul> <li>9600 baud</li> <li>8 data bits</li> <li>no parity bits</li> <li>1 stop bit</li> </ul> <p>The module is communicating with the microcontroller using pins 16 and 17 (Rx &amp; Tx respectively) according to the pinout schema in the image below.</p> <p></p>"},{"location":"data-source/construction/#mpu6050","title":"MPU6050","text":"<p>When it comes to the MPU6050, it communicated a little differently than the GNSS module. This module utilizes the I2C bus. In the image bellow is the modules pin schema. Besides VCC and GND, we need to connect it to the microcontroller with the Serial Clock and Data (SCL and SDA).</p> <p></p> <p>The ESP32 pinout below shows which pins to connect the module to (just follow the pin labels, i.e. SDA to SDA and SCL to SCL).</p> <p></p>"},{"location":"data-source/construction/#leds","title":"LEDs","text":"<p>Besides the two mentioned modules, the solution is equipped with a button and a handful LEDs. See the table below for their purpose as well as their respective GPIO pins.</p> LED GPIO Description Blue 5 Indicates the state of the WiFi hotspot, i.e. LED is ON when the hotspot is enabled Green 4 Positional fix (&gt;= 4 satellites means a locked fix and the LED lights up) Red 18 MQTT message publication (it blinks once for every published message), tells the overall status of MQTT alongside the publish frequency"},{"location":"data-source/construction/#miscellaneous","title":"Miscellaneous","text":"<p>Lastly, a button connected to GPIO pin 15 is used for runtime controls of the WiFi hotspot.</p>"},{"location":"data-source/flashing/","title":"Flashing","text":"<p>There are really two options when it comes to flashing the microcontroller firmware:</p> <ol> <li>Head to releases in the GitHub repository, download the binary and flash it</li> <li>Clone the repository, set-up the environment and use PlatformIO to build the binaries and flash them that way</li> </ol> <p>This page covers both these options.</p>"},{"location":"data-source/flashing/#cloning-the-repository","title":"Cloning the repository","text":"<pre><code>git clone https://github.com/Pzdrs/BP-firmware.git\ncd BP-firmware\n</code></pre> <p>Using your favorite IDE, install the PlatformIO extension and open the project. In the Project view, right click the <code>platformio.ini</code> file and select \"Build\". This will compile the firmware and create a binary file in the <code>.pio/build/nodemcu-32s</code> directory.</p> <p></p> <p>Next, we need to flash the binary to the microcontroller using esptool. You can follow the instructions in the next section to do this.</p>"},{"location":"data-source/flashing/#downloading-the-binary-directly","title":"Downloading the binary directly","text":"<p>After every major change to the firmware the binary is compiled and released on GitHub. All releases can be found at https://github.com/Pzdrs/BP-firmware/releases.</p> <p>We are going to download the binary itself and then use esptool to flash it.</p> <p>So first off, download the binary file from the latest release. For example, to download the binary from the v1.0.0 release, run the following command:</p> <pre><code>wget https://github.com/Pzdrs/BP-firmware/releases/download/v1.0.0/firmware.bin\n</code></pre> <p>Next, we need to flash the binary to the microcontroller. We can use esptool's <code>write_flash</code> command to do this. The command is as follows:</p> <pre><code>python esptool.py -p (PORT) --chip esp32 write_flash firmware.bin\n</code></pre> <p>Common flashing issue</p> <p>For some reason, the ESP32 sometimes refuses to flash because of the incorrect boot mode (in particular, the message \"Wrong boot mode detected (0x13)! The chip needs to be in download mode.\"). This can usually be resolved by just running the command again or by manually putting the ESP32 into download mode.</p> <p>Press and hold the BOOT button on the ESP32, then press and release the EN button. After that, release the BOOT button. The ESP32 should now be in download mode and ready to be flashed.</p>"},{"location":"data-source/troubleshooting/","title":"Troubleshooting","text":"<p>If you don't find the answer to your question here, feel free to raise an issue on our GitHub repository. Please provide as much information as possible, including the Serial logs from the device.</p>"},{"location":"data-source/troubleshooting/#data-source-literally-does-nothing-after-powering-it-on","title":"Data source literally does nothing after powering it on","text":"<p>This sometimes happens and I have no idea why. The only solution I have found is to power cycle the device - either replug the usb cable or simply press the EN button on the ESP. If that doesn't work, try re-flashing the firmware.</p>"},{"location":"data-source/troubleshooting/#my-wifi-network-is-not-showing-up-in-the-list-of-available-networks","title":"My WiFi network is not showing up in the list of available networks","text":"<p>If you're trying to connect to a mobile hotspot, make sure that the hotspot is turned on and that the device is in range. </p> <p>The ESP32 supports 2.4GHz networks only, so make sure that your network is broadcasting on the correct frequency. On iOS, you can check this by going to <code>Settings &gt; Personal Hotspot</code> and make sure that <code>Maximize Compatibility</code> is turned on as seen in the picture below.</p> <p></p> <p>On Android, you can check this by going to <code>Settings &gt; Network &amp; Internet &gt; Wi-Fi &gt; Your Network &gt; Details</code>.</p> <p>If you're still having trouble, power cycling the device should resolve the issue.</p>"},{"location":"data-source/troubleshooting/#nothing-is-happening-the-device-just-sits-there","title":"Nothing is happening, the device just sits there","text":"<p>The GNSS module, if left unpowered for a long time (~12.5 minutes), can take a while to get a fix. It also is very particular about the antenna placement. Here are some tips to get a fix faster:</p> <ul> <li>Make sure the antenna is placed outside, with a clear view of the sky</li> <li>After acquiring a fix, the device needs to send the data to the server, make sure the device is connected to WiFi</li> <li>If the device is still not sending data, try power cycling it</li> </ul> <p>There are multiple indication diodes that can tell you what the device is doing. For more information, check the LED Indicators section.</p>"},{"location":"more/development/","title":"Development","text":""},{"location":"more/development/#development-overview","title":"Development Overview","text":"<p>Depending on which part of the project you want to contribute to, you will need to set up a different environments. The following sections will guide you through setting up the development environment for each part of the project.</p> <p>The project is split into two main parts - the firmware and the web interface, each one with its own repository.</p>"},{"location":"more/development/#firmware","title":"Firmware","text":"<p>The firmware is a C++ application that runs on the ESP32 microcontroller. The firmware is responsible for collecting data from the sensors and sending it to the backend. The firmware is built using PlatformIO, so you will need to have it installed on your machine.</p> <p>The simplest way to get started is with CLion. Click on <code>Get from VCS</code> and paste the link to the repository. CLion will automatically create a CMake project for you.</p> <p> </p>"},{"location":"more/development/#dashboard","title":"Dashboard","text":"<p>The dashboard consists of the backend and the frontend. Both codebases share the same repository, so regardless of which part you want to contribute to, you will need to clone the repository:</p> <pre><code>git clone https://github.com/Pzdrs/BP-app.git\n</code></pre> <p>Any contributions should be made to the <code>develop</code> branch. The <code>main</code> merging process is done by the maintainers.</p>"},{"location":"more/development/#backend","title":"Backend","text":"<p>The backend is a Spring Boot application that uses Gradle as a build and dependency management tool. To run the backend, you will need to have Java 21 installed on your machine.</p> <p>To run the backend, navigate to the <code>backend</code> directory and run the following command:</p> <pre><code>./gradlew bootRun\n</code></pre> <p>If you take a look in <code>main/resources/application.yaml</code>, you will see some environment variables are needed for the application to start. You can either set them in your environment or create a <code>.env</code> file in the <code>backend</code> directory.</p>"},{"location":"more/development/#frontend","title":"Frontend","text":"<p>The frontend of the application is taken care of by VueJS 3. To run the frontend, you will need to have NodeJS installed on your machine.</p> <p>To run the frontend, navigate to the <code>frontend</code> directory and run the following command:</p> <pre><code>npm install\n</code></pre> <p>After all the dependencies are installed, you can run the frontend with:</p> <pre><code>npm run dev\n</code></pre>"}]}